---
title: SSH与SSL
categories:
 - security
---

### 对称加密

- 在1976年以前，所有的加密都采用对称加密，既A使用某种加密规则对信息加密，B收到信息后逆向加密规则解密数据

> 缺点：A如何安全的把加密规则通知B
> 
> 优点：效率高、速度快
> 
> 常见的对称加密算法：DES，AES等

### 非对称加密

```java
1.B(服务器)生成一对两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。
2.A(客户端)获取B生成的公钥，然后用它对信息加密。
3.B得到加密后的信息，用私钥解密。
```

> 最常用的非对称加密算法：RSA


### 对称加密+非对称加密

> 采用非对称加密技术来交换 **对称加密密钥** ，之后的通信都采用对称加密技术加密(先非对称后对称)

### SSH(Secure Shell)

> SSH为 创建在应用层和传输层基础上的安全协议，为计算机上的Shell(壳层)提供安全的传输和使用环境

```java
SSH采用先 非对称后对称 进行数据加密 但是有中间人攻击问题
黑客H埋伏在了A和B之间的某一个路由器上，他假冒B生成一对公私密钥，然后把公钥发送给A，这样A与H之间就建成了一个加密通道，A把所有信息发送给H，H截获A的信息，在假冒A与B通信。
如此一来，A、B之间的通信就完全暴漏给了H，而A、B却完全不知道，这就是的中间人攻击。
```

- SSH协议采用由人工判断公钥的fingerprint是否可信的方式。当使用ssh命令连接服务器时，命令行会提示如下信息:

```shell
RSA key fingerprint is 23:42:c1:e4:3f:d2:cc:37:1d:89:cb:e7:5d:be:5d:53.
Are you sure you want to continue connecting (yes/no)? 
```

fingerprint其实就代表公钥,这种认证方式是指用户已经知道服务器公钥(黑客不可能发一个与服务器一模一样的公钥)，这样就解决了问题

### 为更广大群众设计的SSL与TLS

- SSH弊端：SSH其实是专门为shell设计的一种通信协议，只有SSH客户端，和SSH服务器端之间的通信才能使用这个协议
  
- SSL与TLS(SSL协议的一个后续版本)是一个通用的，建立在应用层之下的一个传输层安全协议，不管是HTTP、FTP等应用层协议都可以依赖的安全通信的传输层协议(应用层和传输层之间的一个安全通道)

> SSH通过fingerprint来解决中间人问题，那么SSL是通过数字证书(CA数字证书认证机构颁发的)来解决的

> 浏览器在与服务器建立SSL连接时，获取服务器的数字证书
> 
> 证书里面有签名(服务器公钥经过CA私钥加密生成的)
> 
> 这样浏览器得到证书，用CA的公钥（每个浏览器都存储着一些权威CA的公钥）对数字签名解密，得到了服务器公钥
> 
> 解密成功说明证书是真的(不是中间人发的)，信任问题就这么解决了，就可以用公钥了

### HTTPS(Hypertext Transfer Protocol Secure)

HTTPS：HTTP over TLS 或者 HTTP over SSL,其实就客户端与服务器之间的HTTP通信基于TLS或SSL协议。

作为网站管理员申请数字证书：首先要为服务器生成一对公私钥，然后将公钥一起发送给某个权威的CA，CA会通过某种方式认证申请人是否真的是网站的所有人，验证通过就会得到证书了。


### 开发

> 如果客户端已经和服务器私底下配置了公钥(客户端),私钥(服务器)，那么不需要证书了(因为确保了这个公钥是从服务器来的)，
> 客户端将对称key通过公钥进行加密，然后服务器通过私钥将其解密，之后的前后端交互通过对称key即可

### 总结

> 服务器生成公私钥，客户端要安全的拿到公钥，然后客户端自己生成一个key用公钥加密传给服务器，之后的数据加解密都是通过这个key
