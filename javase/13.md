---
title: 网络编程
categories:
 - java
---

# 网络编程

### socket

> java.net.Socket:此类实现客户端套接字(套接字是两台机器间通信的端点)
> 
> java.net.ServerSocket:此类实现服务器套接字
> 
> 客户端和服务器端进行交互,必须使用Socket中提供的网络流,不能使用自己创建的流对象
> 
> 当我们创建客户端对象Socket的时候,就会去请求服务器和服务器进行3次握手建立连接通路
> 
> 服务器端必须明确一件事情,必须知道是哪个客户端请求的服务器，使用ServerSocket对象中的方法accept,获取到请求的客户端Socket对象

### tcp/ip

- TCP/IP协议：传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型。

- 链路层：链路层是用于定义物理传输通道，如针对光纤、网线提供的驱动。
- 网络层：整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。
- 传输层：主要是数据传输采用哪种协议，可以采用TCP协议，也可以采用UDP协议。
- 应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。

- UDP:音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响

- TCP:第一次握手，客户端向服务器端发出连接请求，等待服务器确认。第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。第三次握手，客户端再次向服务器端发送确认信息，确认连接。

> 利用`协议`+`IP地址`+`端口号` 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。


### 服务端文件上传

- 循环接收的问题
  
只保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件

```java
// 每次接收新的连接,创建一个Socket对象
while（true）{
    Socket accept = serverSocket.accept();
    ......
}
```

- 效率问题

服务端，在接收大文件时，可能耗费几秒钟的时间，此时阻塞住了，所以使用多线程技术优化

```java
while（true）{
    // 阻塞方法获取新的连接 这里是被阻塞住的 即使很多个客户端(线程)进来也只能有一个进行处理
    // 这里不能写到里面 不然会无限创建线程    
    Socket socket = serverSocket.accept();
    // socket 交给子线程处理 走到循环结束位置后 继续循环处理第二个客户端
    new Thread(() -> {
      	......
        InputStream bis = socket.getInputStream();
      	......
    }).start();
}
```





