---
title: 代理模式
categories:
 - spring
---

### 静态代理

> 三个角色：共同行为、目标对象、代理对象

- 定义行为(共同)

```java
public interface Marry {
    void toMarry();
}
```

- 目标对象(实现行为)

```java
public class You implements Marry {
    @Override
    public void toMarry() {
        System.out.println("我要结婚了...");
    }
}
```

- 代理对象(实现行为或增强目标对象的行为)

```java
public class MarryCompanyProxy implements Marry {
    // 目标对象
    private Marry marry;

    // 通过构造器将目标对象传入
    public MarryCompanyProxy(Marry marry) {
        this.marry = marry;
    }

    // 实现行为
    @Override
    public void toMarry() {
        // 增强行为
        before();
        // 执行目标对象中的方法
        marry.toMarry();
        // 增强行为
        after();
    }

    private void after() {
        System.out.println("新婚快乐，早生贵子！");
    }

    private void before() {
        System.out.println("场地正在布置中...");
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        // 目标对象
        You you = new You();
        // 构造代理角色同时传入真实角色
        MarryCompanyProxy marryCompanyProxy = new MarryCompanyProxy(you);
        // 通过代理对象调用目标对象中的方法
        marryCompanyProxy.toMarry();
    }
}
```

> 场地正在布置中...
> 
> 我要结婚了...
> 
> 新婚快乐，早生贵子！

### 动态代理

> 动态代理类的字节码在程序运行时，由Java反射机制动态产生。
> 
> 它会根据需要，在程序运行期通过反射机制，动态的为目标对象创建代理对象，无需程序员手动编写它的源代码。
> 
> proxy参数传递的即是代理类的实例，method是调用的方法，args是方法的参数

```java
public class JdkHandler implements InvocationHandler {
    // 目标对象的类型不固定，创建时动态生成
    private Object target;

    // 通过构造器将目标对象赋值
    public JdkHandler(Object target) {
        this.target = target;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 增强行为
        System.out.println("方法前执行==============");
        // 调用目标对象的方法（返回Object）
        Object result = method.invoke(target, args);
        // 增强行为
        System.out.println("方法后执行==============");
        return result;
    }

    public Object getProxy() {
        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        // 目标对象
        You you = new You();
        // 构造代理角色同时传入真实角色
        JdkHandler jdkHandler = new JdkHandler(you);
        Marry marry = (Marry) jdkHandler.getProxy();
        // 通过代理对象调用目标对象中的方法
        marry.toMarry();
    }
}
```

- 为了不强制转换，这里利用泛型

```java
public class JdkHandler<T> implements InvocationHandler {
    // 目标对象的类型不固定，创建时动态生成
    private T target;

    // 通过构造器将目标对象赋值
    public JdkHandler(T target) {
        this.target = target;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 增强行为
        System.out.println("方法前执行==============");
        // 调用目标对象的方法（返回T）
        Object result = method.invoke(target, args);
        // 增强行为
        System.out.println("方法后执行==============");
        return result;
    }

    public T getProxy() {
        return (T) Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        // 目标对象
        You you = new You();
        // 构造代理角色同时传入真实角色
        JdkHandler<You> jdkHandler = new JdkHandler<>(you);
        Marry marry = jdkHandler.getProxy();
        // 通过代理对象调用目标对象中的方法
        marry.toMarry();
    }
}
```

> 方法前执行==============
> 
> 我要结婚了...
> 
> 方法后执行==============

- 源码解析

> 以Proxy.newProxyInstance()方法为切入点来剖析代理类的生成及代理方法的调用

```java
    @CallerSensitive
    public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
	    // 如果h为空直接抛出空指针异常，之后所有的单纯的判断null并抛异常，都是此方法
        Objects.requireNonNull(h);
	    // 拷贝类实现的所有接口
        final Class<?>[] intfs = interfaces.clone();
	    // 获取当前系统安全接口
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
	        // Reflection.getCallerClass返回调用该方法的调用类;loader:接口的类加载器进行包访问权限、类加载器权限等检查
            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
        }
 
        // 生成指定的代理类
        Class<?> cl = getProxyClass0(loader, intfs);
        
        try {
            if (sm != null) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }
            // 获取代理类的构造函数对象
            final Constructor<?> cons = cl.getConstructor(constructorParams);
            final InvocationHandler ih = h;
            if (!Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        cons.setAccessible(true);
                        return null;
                    }
                });
            }
	        // 根据代理类的构造函数对象来创建需要返回的代理类对象
            return cons.newInstance(new Object[]{h});
        } catch (IllegalAccessException|InstantiationException e) {
            throw new InternalError(e.toString(), e);
        } catch (InvocationTargetException e) {
            Throwable t = e.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            } else {
                throw new InternalError(t.toString(), t);
            }
        } catch (NoSuchMethodException e) {
            throw new InternalError(e.toString(), e);
        }
    }
```

> newProxyInstance()方法帮我们执行了生成代理类----获取构造器----生成代理对象这三步
> 
> 生成代理类: Class<?> cl = getProxyClass0(loader, intfs);
>
> 获取构造器: final Constructor<?> cons = cl.getConstructor(constructorParams);
>
> 生成代理对象: cons.newInstance(new Object[]{h});

- Proxy.getProxyClass0()生成代理类

```java
private static Class<?> getProxyClass0(ClassLoader loader,Class<?>... interfaces) {
	    // 接口数不得超过65535个，这么大，足够使用的了
        if (interfaces.length > 65535) {
            throw new IllegalArgumentException("interface limit exceeded");
        }
	    //如果缓存中有代理类了直接返回，否则将由代理类工厂ProxyClassFactory创建代理类
        return proxyClassCache.get(loader, interfaces);
    }
```

- 如果缓存中没有代理类，Proxy中的ProxyClassFactory创建代理类

```java
    // key：类加载器；parameter：接口数组
    public V get(K key, P parameter) {
        // 检查指定类型的对象引用不为空null。当参数为null时，抛出空指针异常。
        Objects.requireNonNull(parameter);
		// 清除已经被GC回收的弱引用
        expungeStaleEntries();
		// 将ClassLoader包装成CacheKey, 作为一级缓存的key
        Object cacheKey = CacheKey.valueOf(key, refQueue);
		// 获取得到二级缓存
        ConcurrentMap<Object, Supplier<V>> valuesMap = map.get(cacheKey);
		// 没有获取到对应的值
        if (valuesMap == null) {
            ConcurrentMap<Object, Supplier<V>> oldValuesMap = map.putIfAbsent(cacheKey,valuesMap = new ConcurrentHashMap<>());
            if (oldValuesMap != null) {
                valuesMap = oldValuesMap;
            }
        }
        
		// 根据代理类实现的接口数组来生成二级缓存key
        Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));
		// 通过subKey获取二级缓存值
        Supplier<V> supplier = valuesMap.get(subKey);
        Factory factory = null;
		// 这个循环提供了轮询机制, 如果条件为假就继续重试直到条件为真为止
        while (true) {
            if (supplier != null) {
				// 在这里supplier可能是一个Factory也可能会是一个CacheValue
				// 在这里不作判断, 而是在Supplier实现类的get方法里面进行验证
                V value = supplier.get();
                if (value != null) {
                    return value;
                }
            }
            if (factory == null) {
			    // 新建一个Factory实例作为subKey对应的值
                factory = new Factory(key, parameter, subKey, valuesMap);
            }
            if (supplier == null) {
			    // 到这里表明subKey没有对应的值, 就将factory作为subKey的值放入
                supplier = valuesMap.putIfAbsent(subKey, factory);
                if (supplier == null) {
					// 到这里表明成功将factory放入缓存
                    supplier = factory;
                }
				// 否则, 可能期间有其他线程修改了值, 那么就不再继续给subKey赋值, 而是取出来直接用
            } else {
			    // 期间可能其他线程修改了值, 那么就将原先的值替换
                if (valuesMap.replace(subKey, supplier, factory)) {
					// 成功将factory替换成新的值
                    supplier = factory;
                } else {
					// 替换失败, 继续使用原先的值
                    supplier = valuesMap.get(subKey);
                }
            }
        }
    }
```

> get方法中Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));
>
> subKeyFactory调用apply，具体实现在ProxyClassFactory中完成

- ProxyClassFactory.apply()实现代理类创建

```java
private static final class ProxyClassFactory implements BiFunction<ClassLoader, Class<?>[], Class<?>>
    {
	    // 统一代理类的前缀名都以$Proxy
        private static final String proxyClassNamePrefix = "$Proxy";
        
	    // 使用唯一的编号给作为代理类名的一部分，如$Proxy0,$Proxy1等
        private static final AtomicLong nextUniqueNumber = new AtomicLong();
 
        @Override
        public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {
            Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);
            for (Class<?> intf : interfaces) {
                // 验证指定的类加载器(loader)加载接口所得到的Class对象(interfaceClass)是否与intf对象相同
                Class<?> interfaceClass = null;
                try {
                    interfaceClass = Class.forName(intf.getName(), false, loader);
                } catch (ClassNotFoundException e) {
                }
                if (interfaceClass != intf) {
                    throw new IllegalArgumentException(
                        intf + " is not visible from class loader");
                }
                // 验证该Class对象是不是接口
                if (!interfaceClass.isInterface()) {
                    throw new IllegalArgumentException(
                        interfaceClass.getName() + " is not an interface");
                }
                // 验证该接口是否重复
                if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {
                    throw new IllegalArgumentException(
                        "repeated interface: " + interfaceClass.getName());
                }
            }
	        // 声明代理类所在包
            String proxyPkg = null;  
            int accessFlags = Modifier.PUBLIC | Modifier.FINAL;
            // 验证所有非公共的接口在同一个包内；公共的就无需处理
            for (Class<?> intf : interfaces) {
                int flags = intf.getModifiers();
                if (!Modifier.isPublic(flags)) {
                    accessFlags = Modifier.FINAL;
                    String name = intf.getName();
                    int n = name.lastIndexOf('.');
					// 截取完整包名
                    String pkg = ((n == -1) ? "" : name.substring(0, n + 1));
                    if (proxyPkg == null) {
                        proxyPkg = pkg;
                    } else if (!pkg.equals(proxyPkg)) {
                        throw new IllegalArgumentException(
                            "non-public interfaces from different packages");
                    }
                }
            }
 
            if (proxyPkg == null) {
                // 如果都是public接口，那么生成的代理类就在com.sun.proxy包下如果报java.io.FileNotFoundException: com\sun\proxy\$Proxy0.class(系统找不到指定的路径。)的错误，就先在你项目中创建com.sun.proxy路径
                proxyPkg = ReflectUtil.PROXY_PACKAGE + ".";
            }
 
            // 是一个原子类，确保多线程安全，防止类名重复，类似于：$Proxy0，$Proxy1
            long num = nextUniqueNumber.getAndIncrement();
	        // 代理类的完全限定名，如com.sun.proxy.$Proxy0.calss
            String proxyName = proxyPkg + proxyClassNamePrefix + num;
            // 生成类字节码的方法（重点）
            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
                proxyName, interfaces, accessFlags);
            try {
                return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);
            } catch (ClassFormatError e) {
                throw new IllegalArgumentException(e.toString());
            }
        }
    }
```

- 代理类真正创建在ProxyGenerator.generateProxyClass()
