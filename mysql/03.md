---
title: Mysql事务
categories:
 - mysql
---

### 事务

```java
1. 开启事务：start transaction;
2. 回滚：rollback;
3. 提交：commit;
```

> MySQL数据库中事务默认自动提交,事务提交的两种方式
> 
> 自动提交(mysql就是自动提交的),一条DML(增删改)语句会自动提交一次事务
> 
> 手动提交(Oracle默认是手动提交事务)，需要先开启事务，再提交

```java
1. 事务的四大特征：
	1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。
	2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。
	3. 隔离性：多个事务之间，相互独立。
	4. 一致性：事务操作前后，数据总量不变
2. 事务的隔离级别
	概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。
	存在问题：
		1. 脏读：一个事务，读取到另一个事务中没有提交的数据
		2. 不可重复读：一个事务读取数据，但是读取时间比较长，在第一次读取时的数据为A，另一个事务正好执行update操作，第一个事务再读取时数据不正确了
		3. 幻读：事务A在执行读取操作，读取到了表的数据总量，此时事务B执行了insert或delete并提交事务后，这个时候事务A读取的数据总量和之前统计的不一样
	隔离级别：
		1. read uncommitted：读未提交
			产生的问题：脏读、不可重复读、幻读
		2. read committed：读已提交 （Oracle）
			产生的问题：不可重复读、幻读
		3. repeatable read：可重复读 （MySQL）
			产生的问题：幻读
		4. serializable：串行化
			可以解决所有的问题
3. 不可重复读和幻读
        1. 不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）
        2. 不可重复读是读取了其他事务更改的数据，针对update操作
            解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。
        3. 幻读针对insert和delete操作
            解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。
```

### 悲观锁和乐观锁

> 悲观锁：数据库自身实现，为了保证事务的隔离性，读取数据时加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。

> 乐观锁：基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一
